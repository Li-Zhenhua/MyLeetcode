package 每日一题;

/**
 * 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
'A'：Absent，缺勤
'L'：Late，迟到
'P'：Present，到场
如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：

按 总出勤 计，学生缺勤（'A'）严格 少于两天。
学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。

 */

 
//好烦啊，知道是动规但是老是想不明白转移方程
//定义 dp[i][j][k] 表示前 i 天有 j 个 ‘A’ 且结尾有连续 k 个 ‘L’ 的可奖励的出勤记录的数量

//状态转移：所有的状态都是从前一天，即 i-1，转移而来，但是对于 j 和 k，要分三种情况来讨论：
//当前填入的是 P，i-1 天的任何状态都能转移过来；
//当前填入的是 A，i-1 天即之前肯定没填过 A，同时所有的 late 状态都可以转移到过来。
//当前填入的是 L，i-1 天最多只能有一个连续的 L，其他的状态依次转移过来。

//注意到 dp[i][][] 只会从 dp[i−1][][] 转移得到。因此可以将 dp 中的总天数的维度省略
/*class Solution {
    public int checkRecord(int n) {
        final int MOD = 1000000007;
        int[][][] dp = new int[n+1][2][3];
        dp[0][0][0] = 1; //边界条件
        for (int i = 1; i <= n; i++) {
            //第i天为P时,结尾不存在连续的L
            //注意这里dp[i-1][0][0] + dp[i-1][0][1]这样的都可能超过范围了，所以要先mod
            dp[i][0][0] = ((dp[i-1][0][0] + dp[i-1][0][1]) % MOD + dp[i-1][0][2]) % MOD;
            dp[i][1][0] = ((dp[i-1][1][0] + dp[i-1][1][1]) % MOD + dp[i-1][1][2]) % MOD;

            //第i天为A时,结尾不存在连续的L,且前面不能出现过A
            //注意前面出现过dp[i][1][0]，要合并
            //dp[i][1][0] = (dp[i][1][0] + dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]) % MOD;
            for(int j = 0; j < 3; j++){
                dp[i][1][0] = (dp[i][1][0] + dp[i-1][0][j]) % MOD;
            }

            //第i天为L时,前面只能出现0次或1次L,因为没有加法所以可以不用mod
            dp[i][0][1] = dp[i-1][0][0];
            dp[i][0][2] = dp[i-1][0][1];
            dp[i][1][1] = dp[i-1][1][0];
            dp[i][1][2] = dp[i-1][1][1];
        }

        int ans = 0;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 3; j++) {
                ans += dp[n][i][j];
            }
        }
        return ans;
    }
}*/



//从上面可以看出，第i天只依赖于第i-1天，故这个维度可以优化
class Solution {
    public int checkRecord(int n) {
        final int MOD = 1000000007;
        int[][] dp = new int[2][3];
        dp[0][0] = 1; //边界条件
        for (int i = 1; i <= n; i++) {
            //第i天为P时,结尾不存在连续的L
            //注意这里dp[i-1][0][0] + dp[i-1][0][1]这样的都可能超过范围了，所以要先mod
            dp[0][0] = ((dp[0][0] + dp[0][1]) % MOD + dp[0][2]) % MOD;
            dp[1][0] = ((dp[1][0] + dp[1][1]) % MOD + dp[1][2]) % MOD;

            //第i天为A时,结尾不存在连续的L,且前面不能出现过A
            //注意前面出现过dp[i][1][0]，要合并
            //dp[i][1][0] = (dp[i][1][0] + dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]) % MOD;
            for(int j = 0; j < 3; j++){
                dp[1][0] = (dp[1][0] + dp[0][j]) % MOD;
            }

            //第i天为L时,前面只能出现0次或1次L,因为没有加法所以可以不用mod
            dp[0][1] = dp[0][0];
            dp[0][2] = dp[0][1];
            dp[1][1] = dp[1][0];
            dp[1][2] = dp[1][1];
        }

        int ans = 0;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 3; j++) {
                ans = (ans + dp[i][j]) % MOD;
            }
        }
        return ans;
    }
}

public class _8_18_Q552 {
    
}
